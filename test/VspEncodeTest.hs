module VspEncodeTest (tests) where

import System35.File.Vsp
import System35.Test.Base (assertEqual', assertEqualSeq)
import Test.Framework (defaultMain, testGroup)
import Test.Framework.Providers.HUnit (testCase)
import Test.HUnit
import qualified Data.ByteString as S
import Data.Word (Word8)
import Data.Bits ((.&.), shiftL, shiftR)
import Control.Monad (unless, foldM)

main = defaultMain tests

tests = [ testGroup "Testing encode"
          [ testCase "decode and encode image token" testEncode0
          , testCase "decode, encode and tokenize" testEncode1 ]
        ]

--testEncode0 = assertEqual' "test" expectedBin actualBin
--expectedBin = S.pack $ [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0xff, 0xff]
--actualBin   = S.pack $ [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0xff, 0xff]
testEncode0 =  assertEqualSeq "\n" ret testBlocks
    where
      ret = encode $ decode testBlocks testSize
      testBlocks = [ ByteBlock { code = 0x01
                               , bytes = S.pack [0x01, 0x07, 0x03]
                               , len = 8
                               , sz = 3 }
                   , ByteBlock { code = 0x02
                               , bytes = S.pack [0x02, 0xc3, 0x00, 0x00]
                               , len = 392
                               , sz = 4 }
                   ]
      testSize = (16, 16)

testEncode1 = assertEqualSeq "\n" ret blockdata
    where
      ret = encode $ decode blockdata (16, 400)
      blockdata = tokenize rowdata
      rowdata = S.pack [ 0x01, 0x07, 0x03, 0x02, 0xc3, 0x00, 0x00, 0x01, 0x06, 0x01
                       , 0x02, 0xc3, 0x00, 0x00, 0x07, 0x00, 0x02, 0xc7, 0x00, 0x00
                       , 0x02, 0xc7, 0x00, 0x00, 0x02, 0x03, 0x00, 0xff, 0xa5, 0x02
                       , 0x90, 0xe7, 0xe7, 0xe0, 0xe0,  0xe7, 0xe7, 0x01, 0x59, 0xe6
                       , 0xe7, 0xe7, 0xe0, 0xe0, 0xff, 0xff, 0xff, 0x01, 0x06, 0xff
                       , 0x07, 0x00, 0x02, 0x8f, 0x42, 0x42, 0x42, 0x43, 0x40, 0x40
                       , 0x40, 0x40, 0x43, 0x01, 0x59, 0x42, 0x43, 0x40, 0x40, 0x40
                       , 0x40, 0x7f, 0x07, 0x00, 0x02, 0xc7, 0x00, 0x00, 0x02, 0xc7
                       , 0x00, 0x00 ]

      expected = [ ( concat [ repeat1 8 0x03, repeat2 196 (0x00,0x00) ]
                   , concat [ repeat1 7 0x01, repeat2 196 (0x00,0x00), [0x00] ]
                   , concat [ repeat2 200 (0x00,0x00) ]
                   , concat [ repeat2 200 (0x00,0x00) ] )
                 , ( concat [ repeat2 4 (0x00,0xff), [0xa5], repeat1 290 0xe7
                            , [0xe0, 0xe0, 0xe7, 0xe7], repeat1 90 0xe6
                            , [0xe7, 0xe7, 0xe0, 0xe0, 0xff, 0xff, 0xff] ]
                   , concat [ repeat1 7 0xff, [0x00], repeat1 288 0x42
                            , [0x42, 0x43, 0x40, 0x40, 0x40, 0x40, 0x43]
                            , repeat1 90 0x42
                            , [0x43, 0x40, 0x40, 0x40, 0x40, 0x7f, 0x00] ]
                   , concat [ repeat2 200 (0x00,0x00) ]
                   , concat [ repeat2 200 (0x00,0x00) ] ) ]

      repeat1 k x = take k (repeat x) -- for 0x01
      repeat2 k (x1,x2) = concat $ take k (repeat [x1,x2]) -- for 0x02
